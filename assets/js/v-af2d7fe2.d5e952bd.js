"use strict";(self.webpackChunkfixture_riveter=self.webpackChunkfixture_riveter||[]).push([[744],{8301:(e,t,i)=>{i.r(t),i.d(t,{data:()=>n});const n={key:"v-af2d7fe2",path:"/guide/glossary.html",title:"Glossary",lang:"en-US",frontmatter:{},excerpt:"",headers:[{level:2,title:"Instance",slug:"instance",children:[]},{level:2,title:"Scope",slug:"scope",children:[{level:3,title:"Precedence",slug:"precedence",children:[]}]}],filePathRelative:"guide/glossary.md"}},9359:(e,t,i)=>{i.r(t),i.d(t,{default:()=>_});var n=i(6252);const r=(0,n._)("h1",{id:"glossary",tabindex:"-1"},[(0,n._)("a",{class:"header-anchor",href:"#glossary","aria-hidden":"true"},"#"),(0,n.Uk)(" Glossary")],-1),a=(0,n._)("h2",{id:"instance",tabindex:"-1"},[(0,n._)("a",{class:"header-anchor",href:"#instance","aria-hidden":"true"},"#"),(0,n.Uk)(" Instance")],-1),s=(0,n.Uk)('Instead of fumbling with awkward phrasing like "currently constructed object" or "building a fixture", the word "instance" will be used when referring to the object that is being constructed or has been constructed from a given fixture\'s definition. The phrases "building an instance" or "building an instance of a/the fixture" will also be used when referring to the process of constructing an object from a given fixture\'s definition. The word "build" overlaps with the default '),l=(0,n.Uk)("Strategy"),d=(0,n.Uk)(" method "),o=(0,n._)("code",null,"build",-1),c=(0,n.Uk)(", but its use in these phrases is deliberately Strategy-agnostic."),h=(0,n._)("div",{class:"custom-container danger"},[(0,n._)("p",{class:"custom-container-title"},"TODO"),(0,n._)("p",null,"Add examples and stuff to clarify")],-1),u=(0,n._)("h2",{id:"scope",tabindex:"-1"},[(0,n._)("a",{class:"header-anchor",href:"#scope","aria-hidden":"true"},"#"),(0,n.Uk)(" Scope")],-1),f=(0,n.Uk)("Nested fixtures and traits can define a given attribute multiple times. The order they are applied (the precedence) is determined by "),p={href:"https://en.wikipedia.org/wiki/Scope_(computer_science)#Dynamic_scope",target:"_blank",rel:"noopener noreferrer"},g=(0,n.Uk)("dynamic scope"),b=(0,n.Uk)(": For a given fixture, the list of attributes to assign to the "),m=(0,n._)("a",{href:"#instance"},"instance",-1),y=(0,n.Uk)(" is determined by walking up the hierarchy of parent fixtures, gathering each defined attribute. When traits are referenced in a definition, they are fully resolved (traits referencing traits will be walked until a given trait doesn't reference any others), and the resulting set of attributes is treated as if they were inlined. Traits passed in as arguments (when calling a Strategy method on "),k=(0,n._)("code",null,"fr",-1),w=(0,n.Uk)(") are treated the same way, except they are considered to be inline with the innermost fixture definition. All attribute overrides passed in when calling a Strategy method are considered to be inline with the innermost fixture definition as well. Once the full list is gathered, only the innermost defined definition for each attribute is used."),x=(0,n.uE)('<p>This same process is used when gathering hooks, except all hooks are run instead of only the latest.</p><h3 id="precedence" tabindex="-1"><a class="header-anchor" href="#precedence" aria-hidden="true">#</a> Precedence</h3><p>Higher means will be selected/run first if it exists:</p><ul><li>Attribute overrides</li><li>Trait argument list</li><li>Inline definitions</li><li>Inline trait references</li><li>Parent/nesting fixture definitions</li><li>Parent/nesting fixture trait references</li><li>Global trait references</li></ul><p>An example:</p><div class="custom-container danger"><p class="custom-container-title">TODO</p><p>Figure out a good example here. Lots of examples in the tests but those are opaque.</p></div>',6),_={render:function(e,t){const i=(0,n.up)("RouterLink"),_=(0,n.up)("OutboundLink");return(0,n.wg)(),(0,n.iD)(n.HY,null,[r,a,(0,n._)("p",null,[s,(0,n.Wm)(i,{to:"/api/strategy.html"},{default:(0,n.w5)((()=>[l])),_:1}),d,o,c]),h,u,(0,n._)("p",null,[f,(0,n._)("a",p,[g,(0,n.Wm)(_)]),b,m,y,k,w]),x],64)}}}}]);