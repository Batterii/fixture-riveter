import {Model} from "../support/model";
import {FixtureRiveter} from "../../lib/fixture-riveter";
import {ObjectionAdapter} from "../../lib/adapters/objection-adapter";
import {createTable} from "../support/define-helpers";
import {expect} from "chai";
import {camelCase} from "lodash";

describe("Traits", function() {
	let fr: FixtureRiveter;

	class User extends Model {
		name: string;
		age: number;
		admin: boolean;
		email: string;

		get props() {
			return {
				name: "string",
				age: "integer",
				admin: "boolean",
				email: "string",
			};
		}
	}

	before(async function() {
		await createTable(User);

		fr = new FixtureRiveter();
		fr.setAdapter(new ObjectionAdapter());

		fr.fixture("user", User, (f) => {
			f.name(() => "Noah");
			f.age(() => 32);
			f.admin(() => false);
			f.sequence("email", (n) => `test${n}@foo.bar`);

			f.trait("old", (t) => {
				t.age(() => 100);
			});

			f.trait("admin", (t) => {
				t.admin(() => true);
			});
		});
	});

	it("can apply traits to a fixture instance", async function() {
		const user = await fr.build("user", ["old"], {name: "Bogart"});
		expect(user.age).to.equal(100);
		expect(user.name).to.equal("Bogart");
	});

	it("can apply multiple traits to a fixture instance", async function() {
		const user = await fr.create("user", ["old", "admin"], {name: "Bogart"});
		expect(user.age).to.equal(100);
		expect(user.admin).to.be.true;
	});
});

describe("tests from fixture_bot", function() {
	class User extends Model {
		id: number;
		name: string;
		age: number;
		admin: boolean;
		gender: string;
		email: string;
		dateOfBirth: Date;
		great: string;

		get props() {
			return {
				name: "string",
				age: "integer",
				admin: "boolean",
				gender: "string",
				email: "string",
				dateOfBirth: "date",
				great: "string",
			};
		}
	}

	before(async function() {
		await createTable(User);
	});

	describe("an instance generated by a fixture with multiple traits", function() {
		let fr: FixtureRiveter;

		before(async function() {
			fr = new FixtureRiveter();

			fr.fixture("userWithoutAdminScoping", User, (f) => {
				f.attr("adminTrait");
			});

			fr.fixture("user", User, (f) => {
				f.attr("name", () => "John");

				f.trait("great", (t) => {
					t.attr("great", () => "GREAT!!!");
				});

				f.trait("great", (t) => {
					t.attr("great", () => "EVEN GREATER!!!");
				});

				f.trait("admin", (t) => {
					t.attr("admin", () => true);
				});

				f.trait("adminTrait", (t) => {
					t.attr("admin", () => true);
				});

				f.trait("male", (t) => {
					t.attr("name", () => "Joe");
					t.attr("gender", () => "Male");
				});

				f.trait("female", (t) => {
					t.attr("name", () => "Jane");
					t.attr("gender", () => "Female");
				});

				f.fixture("greatUser", (ff) => {
					ff.attr("great");
				});

				f.fixture("evenGreaterUser", (ff) => {
					ff.attr("great");

					ff.trait("great", (t) => {
						t.attr("great", () => "EVEN GREATER!!!");
					});
				});

				f.fixture("admin", {traits: ["admin"]});

				f.fixture("maleUser", (ff) => {
					ff.attr("male");

					ff.fixture("childMaleUser", (fff) => {
						fff.attr("dateOfBirth", () => new Date("1/1/2020"));
					});
				});

				f.fixture("female", {traits: ["female"]}, (ff) => {
					ff.trait("admin", (t) => {
						t.attr("admin", () => true);
						t.attr("name", () => "Judy");
					});

					ff.fixture("femaleGreatUser", (fff) => {
						fff.attr("great");
					});

					ff.fixture("femaleAdminJudy", {traits: ["admin"]});
				});

				f.fixture("femaleAdmin", {traits: ["female", "admin"]});
				f.fixture("femaleAfterMaleAdmin", {traits: ["male", "female", "admin"]});
				f.fixture("maleAfterFemaleAdmin", {traits: ["female", "male", "admin"]});
			});

			fr.trait("email", (t) => {
				t.attr("email", async(e) => `${await e.attr("name")}@example.com`);
			});

			fr.fixture("userWithEmail", User, {traits: ["email"]}, (f) => {
				f.attr("name", () => "Bill");
			});
		});

		specify("the parent class", async function() {
			const user = await fr.build("user");
			expect(user.name).to.equal("John");
			expect(user.gender).to.not.exist;
			expect(user.admin).to.not.exist;
		});

		specify("the child class with one trait", async function() {
			const user = await fr.build("admin");
			expect(user.name).to.equal("John");
			expect(user.gender).to.not.exist;
			expect(user.admin).to.be.true;
		});

		specify("the other child class with one trait", async function() {
			const user = await fr.build("female");
			expect(user.name).to.equal("Jane");
			expect(user.gender).to.equal("Female");
			expect(user.admin).to.not.exist;
		});

		specify("the child with multiple traits", async function() {
			const user = await fr.build("femaleAdmin");
			expect(user.name).to.equal("Jane");
			expect(user.gender).to.equal("Female");
			expect(user.admin).to.be.true;
		});

		specify("the child with multiple traits and overridden attributes", async function() {
			const user = await fr.build("femaleAdmin", {name: "Jill", gender: undefined});
			expect(user.name).to.equal("Jill");
			expect(user.gender).to.not.exist;
			expect(user.admin).to.be.true;
		});

		context("the child with multiple traits who override the same attribute", function() {
			specify("when the male assigns name after female", async function() {
				const user = await fr.build("maleAfterFemaleAdmin");
				expect(user.name).to.equal("Joe");
				expect(user.gender).to.equal("Male");
				expect(user.admin).to.be.true;
			});

			specify("when the female assigns name after male", async function() {
				const user = await fr.build("femaleAfterMaleAdmin");
				expect(user.name).to.equal("Jane");
				expect(user.gender).to.equal("Female");
				expect(user.admin).to.be.true;
			});
		});

		specify("child class with scoped trait and inherited trait", async function() {
			const user = await fr.build("femaleAdminJudy");
			expect(user.name).to.equal("Judy");
			expect(user.gender).to.equal("Female");
			expect(user.admin).to.be.true;
		});

		specify("fixture using global trait", async function() {
			const user = await fr.build("userWithEmail");
			expect(user.name).to.equal("Bill");
			expect(user.email).to.equal("Bill@example.com");
		});

		context("fixture created with alternate syntax for specifying trait", function() {
			specify("creation works", async function() {
				const user = await fr.build("maleUser");
				expect(user.gender).to.equal("Male");
			});

			specify("where trait name and attribute are the same", async function() {
				const user = await fr.build("greatUser");
				expect(user.great).to.equal("GREAT!!!");
			});

			specify(
				"where trait name and attribute are the same and attribute is overridden",
				async function() {
					const user = await fr.build("greatUser", {great: "SORT OF!!!"});
					expect(user.great).to.equal("SORT OF!!!");
				},
			);
		});

		context("fixture with trait defined multiple times", function() {
			specify("creation works", async function() {
				const user = await fr.build("greatUser");
				expect(user.great).to.equal("GREAT!!!");
			});

			specify("child fixture redefining trait", async function() {
				const user = await fr.build("evenGreaterUser");
				expect(user.great).to.equal("EVEN GREATER!!!");
			});
		});

		specify("child fixture created where trait attributes are inherited", async function() {
			const user = await fr.build("childMaleUser");
			expect(user.gender).to.equal("Male");
			expect(user.dateOfBirth).to.deep.equal(new Date("1/1/2020"));
		});

		specify("fixture outside of scope", async function() {
			const fn = async() => fr.build("userWithoutAdminScoping");
			expect(fn).to.throw;
		});

		specify("child fixture using grandparents' trait", async function() {
			const user = await fr.build("femaleGreatUser");
			expect(user.great).to.equal("GREAT!!!");
		});
	});

	describe("looking up traits that don't exist", function() {
		it("raises an error", async function() {
			const fr = new FixtureRiveter();
			fr.fixture("user", User);
			const fn = async() => fr.build("user", ["missing trait"]);
			return expect(Promise.resolve(fn())).to.eventually.be.rejected;
		});
	});

	specify("traits and dynamic attributes that are applied simultaneously", async function() {
		const fr = new FixtureRiveter();

		fr.trait("email", (f) => {
			f.attr("email", async(e) => `${await e.attr("name")}@example.com`);
		});

		fr.fixture("user", User, (f) => {
			f.attr("name", () => "John");
			f.attr("email");
			f.attr("combined", async(e) => {
				return `${await e.attr("name")} <${await e.attr("email")}>`;
			});
		});

		const user = await fr.build("user");
		expect(user.name).to.equal("John");
		expect(user.email).to.equal("John@example.com");
		expect(user.combined).to.equal("John <John@example.com>");
	});

	describe("inline traits overriding existing attributes", function() {
		let fr: FixtureRiveter;
		class Action extends Model {
			id: number;
			status: string;

			get props() {
				return {status: "string"};
			}
		}

		before(async function() {
			await createTable(Action);

			fr = new FixtureRiveter();

			fr.fixture("action", Action, (f) => {
				f.attr("status", () => "pending");

				f.trait("accepted", (t) => {
					t.attr("status", () => "accepted");
				});

				f.trait("declined", (t) => {
					t.attr("status", () => "declined");
				});

				f.fixture("declinedAction", {traits: ["declined"]});
				f.fixture("extendedDeclinedAction", {traits: ["declined"]}, (ff) => {
					ff.attr("status", () => "extended declined");
				});
			});
		});

		it("returns the default status", async function() {
			const action = await fr.build("action");
			expect(action.status).to.equal("pending");
		});

		it("prefers inline trait attributes over default attributes", async function() {
			const action = await fr.build("action", ["accepted"]);
			expect(action.status).to.equal("accepted");
		});

		it("prefers traits on a fixture over default attributes", async function() {
			const action = await fr.build("declinedAction");
			expect(action.status).to.equal("declined");
		});

		it("prefers inline trait attributes over traits on a fixture", async function() {
			const action = await fr.build("declinedAction", ["accepted"]);
			expect(action.status).to.equal("accepted");
		});

		it(
			"prefers attributes on factories over attributes from non-inline traits",
			async function() {
				const action = await fr.build("extendedDeclinedAction");
				expect(action.status).to.equal("extended declined");
			},
		);

		it("prefers inline traits over attributes on factories", async function() {
			const action = await fr.build("extendedDeclinedAction", ["accepted"]);
			expect(action.status).to.equal("accepted");
		});

		it(
			`prefers overridden attributes over attributes from traits,
			inline traits, or attributes on factories`,
			async function() {
				const action = await fr.build(
					"extendedDeclinedAction",
					["accepted"],
					{status: "completely overriden"},
				);
				expect(action.status).to.equal("completely overriden");
			},
		);
	});

	describe("making sure the fixture is compiled the first time we instantiate it", function() {
		let fr: FixtureRiveter;

		before(async function() {
			await createTable(User);

			fr = new FixtureRiveter();

			fr.fixture("user", User, (f) => {
				f.trait("female", (t) => t.attr("gender", () => "female"));
				f.trait("admin", (t) => t.attr("role", () => "admin"));

				f.fixture("femaleUser", (ff) => {
					ff.attr("female");
				});
			});
		});

		it("can honor traits on the very first call", async function() {
			const user = await fr.build("femaleUser", ["admin"], {age: 30});
			expect(user.gender).to.equal("female");
			expect(user.age).to.equal(30);
			expect(user.role).to.equal("admin");

			const user1 = await fr.build("femaleUser", {age: 30});
			expect(user1.gender).to.equal("female");
			expect(user1.age).to.equal(30);
			expect(user1.role).to.be.undefined;

			const user2 = await fr.build("femaleUser");
			expect(user2.gender).to.equal("female");
			expect(user2.age).to.be.undefined;
			expect(user2.role).to.be.undefined;
		});
	});
});

describe("#968", function() {
	let fr: FixtureRiveter;
	class Demo extends Model {
		id: number;
		value: string;

		get props() {
			return {value: "string"};
		}
	}

	beforeEach(async function() {
		await createTable(Demo);
		fr = new FixtureRiveter();

		fr.fixture("parent", Demo, (f) => {
			f.trait("y", (t) => {
				t.attr("value", () => "parent value");
			});

			f.trait("z", (t) => {
				t.attr("y");
			});

			f.fixture("child", (ff) => {
				ff.trait("y", (t) => {
					t.attr("value", () => "child value");
				});
			});
		});
	});

	specify("parent first", async function() {
		const parent = await fr.build("parent", ["z"]);
		const child = await fr.build("child", ["z"]);

		expect(parent.value).to.equal("parent value");
		expect(child.value).to.equal("child value");
	});

	specify("child first", async function() {
		const child = await fr.build("child", ["z"]);
		const parent = await fr.build("parent", ["z"]);

		expect(parent.value).to.equal("parent value");
		expect(child.value).to.equal("child value");
	});
});

describe("traitsForEnum", function() {
	let fr: FixtureRiveter;

	class User extends Model {
		name: string;
	}

	it("correctly generates all possible traits", async function() {
		fr = new FixtureRiveter();
		fr.fixture(User, (f) => {
			f.name(() => "Noah");
			f.traitsForEnum("name", ["Robert Bobert", "Jaime", "Mortimer"]);
		});

		let user = await fr.build(User);
		expect(user.name).to.equal("Noah");
		user = await fr.build(User, ["Robert Bobert"]);
		expect(user.name).to.equal("Robert Bobert");
		user = await fr.build(User, ["Jaime"]);
		expect(user.name).to.equal("Jaime");
		user = await fr.build(User, ["Mortimer"]);
		expect(user.name).to.equal("Mortimer");
	});

	it("accepts a function to change trait string", async function() {
		fr = new FixtureRiveter();
		fr.fixture(User, (f) => {
			f.name(() => "Noah");
			f.traitsForEnum(
				"name",
				["Robert Bobert", "Jaime", "Mortimer"],
				(s) => s.toUpperCase(),
			);
		});

		let user = await fr.build(User);
		expect(user.name).to.equal("Noah");
		user = await fr.build(User, ["ROBERT BOBERT"]);
		expect(user.name).to.equal("Robert Bobert");
		user = await fr.build(User, ["JAIME"]);
		expect(user.name).to.equal("Jaime");
		user = await fr.build(User, ["MORTIMER"]);
		expect(user.name).to.equal("Mortimer");
	});

	it("global converter can be set", async function() {
		fr = new FixtureRiveter();
		fr.setTraitsForEnumCallback((s) => camelCase(s));

		fr.fixture(User, (f) => {
			f.name(() => "Noah");
			f.traitsForEnum(
				"name",
				["Robert Bobert", "Jaime", "Mortimer"],
			);
		});

		let user = await fr.build(User);
		expect(user.name).to.equal("Noah");
		user = await fr.build(User, ["robertBobert"]);
		expect(user.name).to.equal("Robert Bobert");
		user = await fr.build(User, ["jaime"]);
		expect(user.name).to.equal("Jaime");
		user = await fr.build(User, ["mortimer"]);
		expect(user.name).to.equal("Mortimer");
	});

	it("throws an error if callback isn't functioni", function() {
		fr = new FixtureRiveter();

		expect(() => {
			fr.fixture(User, (f) => {
				f.traitsForEnum(
					"name",
					["Robert Bobert", "Jaime", "Mortimer"],
					"hello" as any,
				);
			});
		}).to.throw("Callback hello for traitsForEnum name must be a function");
	});
});
